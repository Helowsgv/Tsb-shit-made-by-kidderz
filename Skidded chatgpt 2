--// Script 1: death counter notif

-- Death Counter Notifier with Highlight Integration (Persistent after Respawn)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

-- UI setup function
local function createUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "DeathCounterNotifierGUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

    local notificationFrame = Instance.new("Frame")
    notificationFrame.Name = "NotificationFrame"
    notificationFrame.Size = UDim2.new(0, 250, 0, 100)
    notificationFrame.Position = UDim2.new(1, -260, 1, -110)
    notificationFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    notificationFrame.BackgroundTransparency = 0.3
    notificationFrame.BorderSizePixel = 0
    notificationFrame.Visible = false
    notificationFrame.Parent = screenGui

    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(1, 0, 0.4, 0)
    titleLabel.Position = UDim2.new(0, 0, 0, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = "Death Counter Detected"
    titleLabel.TextColor3 = Color3.fromRGB(255, 50, 50)
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.TextScaled = true
    titleLabel.Parent = notificationFrame

    local nameLabel = Instance.new("TextLabel")
    nameLabel.Size = UDim2.new(1, 0, 0.6, 0)
    nameLabel.Position = UDim2.new(0, 0, 0.4, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = ""
    nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    nameLabel.Font = Enum.Font.Gotham
    nameLabel.TextScaled = true
    nameLabel.Parent = notificationFrame

    return screenGui, notificationFrame, nameLabel
end

local screenGui, notificationFrame, nameLabel = createUI()

-- Improved highlight using Roblox Highlight object
local highlightInstances = {}

local function updateHighlight(model, state)
    if not highlightInstances[model] and state then
        local highlight = Instance.new("Highlight")
        highlight.Name = "DeathCounterHighlight"
        highlight.FillColor = Color3.fromRGB(255, 0, 0)
        highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
        highlight.FillTransparency = 0.5
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Adornee = model
        highlight.Parent = model
        highlightInstances[model] = highlight
    elseif highlightInstances[model] and not state then
        highlightInstances[model]:Destroy()
        highlightInstances[model] = nil
    end
end

local function monitorDeathCounters()
    RunService.RenderStepped:Connect(function()
        local found = false
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                local model = Workspace:FindFirstChild("Live") and Workspace.Live:FindFirstChild(player.Name)
                if model then
                    local hasCounter = model:FindFirstChild("Counter") ~= nil
                    updateHighlight(model, hasCounter)

                    if hasCounter then
                        found = true
                        notificationFrame.Visible = true
                        nameLabel.Text = player.Name
                    end
                end
            end
        end

        if not found then
            notificationFrame.Visible = false
            nameLabel.Text = ""
        end
    end)
end

-- Initial start and persistent respawn connection
monitorDeathCounters()

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1) -- wait to ensure GUI and workspace are fully ready
    screenGui:Destroy()
    screenGui, notificationFrame, nameLabel = createUI()
end)

--// Script 2: Noclik when garo parre

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local localPlayer = Players.LocalPlayer
local queuedClick = false
local counterStartTime = 0
local counterDuration = 0.705
local lastTargetName = nil

-- Get target if it has HunterCounter
local function getCounterTarget()
	local success, result = pcall(function()
		local live = workspace:FindFirstChild("Live")
		local playerData = live and live:FindFirstChild(localPlayer.Name)
		if not playerData then return nil end

		local attr = playerData:GetAttribute("LastM1Hitted")
		if not attr then return nil end

		local name = string.split(attr, ";;")[1]
		local target = live:FindFirstChild(name)
		if not target then return nil end

		if target:FindFirstChild("HunterCounter") then
			return target, name
		end

		return nil
	end)
	if success then return result end
end

-- Handle M1 click input
local function onInput(actionName, inputState, inputObject)
	if inputState == Enum.UserInputState.Begin and inputObject.UserInputType == Enum.UserInputType.MouseButton1 then
		local target, name = getCounterTarget()
		if target then
			if not queuedClick then
				counterStartTime = tick()
				queuedClick = true
				lastTargetName = name
				warn("M1 queued due to HunterCounter")
			end
			return Enum.ContextActionResult.Sink
		end
	end
	return Enum.ContextActionResult.Pass
end

-- Monitor queue and release click at perfect time
RunService.RenderStepped:Connect(function()
	if queuedClick and lastTargetName then
		local live = workspace:FindFirstChild("Live")
		local target = live and live:FindFirstChild(lastTargetName)

		-- If counter disappeared or time passed, fire click
		local stillHasCounter = target and target:FindFirstChild("HunterCounter")
		if tick() - counterStartTime >= counterDuration or not stillHasCounter then
			queuedClick = false
			lastTargetName = nil
			VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
			VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
			warn("M1 auto-fired at end of HunterCounter")
		end
	end
end)

-- Bind input blocking
ContextActionService:BindAction("BlockM1IfHunterCounter", onInput, false, Enum.UserInputType.MouseButton1)


--// Script 3: Blocking

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local player = Players.LocalPlayer

local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Config
local MAX_DISTANCE = 30
local SMOOTHNESS = 0.20
local MAX_VELOCITY = 100

local DEFAULT_PREDICT_TIME = 0.3
local RUN_PREDICT_TIME = 0.1
local DASH_PREDICT_TIME = 0.4

-- State
local isRagdolled = false
local hasTarget = false
local scriptActive = true

-- ✅ GUI Checkmark
local function createCheckmark()
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "BlockCheckGui"
	screenGui.ResetOnSpawn = false
	screenGui.Parent = player:WaitForChild("PlayerGui")

	local label = Instance.new("TextLabel")
	label.Name = "BlockIndicator"
	label.Size = UDim2.new(0, 120, 0, 35)
	label.Position = UDim2.new(0, 10, 0, 10)
	label.BackgroundTransparency = 1
	label.Text = "🛡️ Blocking"
	label.TextColor3 = Color3.fromRGB(0, 255, 0)
	label.TextScaled = true
	label.Visible = false
	label.Parent = screenGui

	return label
end

local blockIndicator = createCheckmark()

-- Helpers
local function getLiveModel()
	local live = Workspace:FindFirstChild("Live")
	return live and live:FindFirstChild(player.Name)
end

local function isBlocking()
	if not scriptActive then return false end
	local live = getLiveModel()
	local value = live and live:GetAttribute("Blocking")
	blockIndicator.Visible = value == true
	return value == true
end

local function isAlive()
	return humanoid and humanoid.Health > 0
end

local function getNearestHumanoid()
	if not scriptActive then return nil end
	local liveFolder = Workspace:FindFirstChild("Live")
	if not liveFolder then return nil end

	local closest = nil
	local shortest = MAX_DISTANCE

	for _, model in pairs(liveFolder:GetChildren()) do
		if model:IsA("Model") and model.Name ~= player.Name then
			local h = model:FindFirstChild("Humanoid")
			local r = model:FindFirstChild("HumanoidRootPart")
			if h and r then
				local dist = (rootPart.Position - r.Position).Magnitude
				if dist <= shortest then
					shortest = dist
					closest = model
				end
			end
		end
	end

	return closest
end

-- 🔁 Frame Update
RunService.RenderStepped:Connect(function()
	if not scriptActive or not isAlive() then
		if humanoid then humanoid.AutoRotate = false end
		if blockIndicator then blockIndicator.Visible = false end
		return
	end

	local blocking = isBlocking()
	if not blocking then
		humanoid.AutoRotate = true
		blockIndicator.Visible = false
		return
	end

	local target = getNearestHumanoid()
	if not target then
		if hasTarget then
			humanoid.AutoRotate = true
			hasTarget = false
		end
		return
	end

	local targetRoot = target:FindFirstChild("HumanoidRootPart")
	if not targetRoot then return end

	hasTarget = true
	humanoid.AutoRotate = false

	local velocity = targetRoot.Velocity
	if velocity.Magnitude > MAX_VELOCITY then
		velocity = Vector3.zero
	end

	local predictionTime = DEFAULT_PREDICT_TIME
	local smoothness = SMOOTHNESS

	local liveTarget = Workspace:FindFirstChild("Live") and Workspace.Live:FindFirstChild(target.Name)
	if liveTarget then
		if liveTarget:GetAttribute("_JustDashed") ~= nil then
			predictionTime = DASH_PREDICT_TIME
			smoothness = 0
		elseif liveTarget:GetAttribute("Running") == true then
			predictionTime = RUN_PREDICT_TIME
		end
	end

	local predictedPos = targetRoot.Position + (velocity * predictionTime)
	local lookAtPos = Vector3.new(predictedPos.X, rootPart.Position.Y, predictedPos.Z)
	local desired = CFrame.lookAt(rootPart.Position, lookAtPos)
	rootPart.CFrame = rootPart.CFrame:Lerp(desired, smoothness)
end)

-- 🔐 Ragdoll Control
local function updateRagdollState(ragdollPresent)
	isRagdolled = ragdollPresent
	scriptActive = not ragdollPresent

	if not scriptActive then
		if humanoid then humanoid.AutoRotate = false end
		if blockIndicator then blockIndicator.Visible = false end
	end
end

-- 👀 Watch for Ragdoll
local function setupRagdollWatcher()
	local live = getLiveModel()
	if not live then return end

	updateRagdollState(live:FindFirstChild("Ragdoll") ~= nil)

	live.ChildAdded:Connect(function(child)
		if child.Name == "Ragdoll" then
			updateRagdollState(true)
		end
	end)

	live.ChildRemoved:Connect(function(child)
		if child.Name == "Ragdoll" then
			updateRagdollState(false)
		end
	end)
end

-- 🧍 Respawn Support (fix stuck facing old direction)
player.CharacterAdded:Connect(function(char)
	character = char
	humanoid = character:WaitForChild("Humanoid")
	rootPart = character:WaitForChild("HumanoidRootPart")

	-- 🧼 Reset state
	hasTarget = false
	scriptActive = true
	isRagdolled = false

	if humanoid then
		humanoid.AutoRotate = true -- ✅ Let player rotate again
	end

	if blockIndicator then
		blockIndicator.Visible = false
	end

	-- Re-setup ragdoll watcher
	task.delay(0.5, function()
		setupRagdollWatcher()
	end)
end)

-- Initial ragdoll watcher setup
task.spawn(function()
	repeat task.wait() until getLiveModel()
	setupRagdollWatcher()
end)


--// Script 4: Dashers

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Create GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "QClickGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

-- Create Button
local button = Instance.new("TextButton")
button.Name = "QButton"
button.Size = UDim2.new(0, 40, 0, 40)
button.Position = UDim2.new(1, -50, 0.5, -20)
button.BackgroundColor3 = Color3.new(0, 0, 0)
button.TextColor3 = Color3.new(1, 1, 1)
button.Text = "Q"
button.Active = true
button.Draggable = true
button.Parent = screenGui

-- Function to simulate Q press
local function simulateQ()
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Q, false, game)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Q, false, game)
end

-- Click GUI to simulate Q
button.MouseButton1Click:Connect(simulateQ)

-- Spam Q while E is held
local spamming = false

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.E and not spamming then
        spamming = true
        task.spawn(function()
            while spamming do
                simulateQ()
                task.wait(0.05) -- 20 Qs per second
            end
        end)
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.E then
        spamming = false
    end
end)


--// Script 5: dash reset

local plr = game:GetService("Players").LocalPlayer
local uis = game:GetService("UserInputService")
local stgui = game:GetService("StarterGui")

local frontDashArgs = {
	[1] = {
		["Dash"] = Enum.KeyCode.W,
		["Key"] = Enum.KeyCode.Q,
		["Goal"] = "KeyPress"
	}
}

local function frontDash()
	plr.Character.Communicate:FireServer(unpack(frontDashArgs))
end

local function noEndlagSetup(char)
	uis.InputBegan:Connect(function(input, t)
		if t then return end
		
		if input.KeyCode == Enum.KeyCode.Q and not uis:IsKeyDown(Enum.KeyCode.D) and not uis:IsKeyDown(Enum.KeyCode.A) and not uis:IsKeyDown(Enum.KeyCode.S) and char:FindFirstChild("UsedDash") then
			frontDash()
		end
	end)
end

local function stopAnimation(char, animationId)
    local humanoid = char:FindFirstChildWhichIsA("Humanoid")
    if humanoid then
        local animator = humanoid:FindFirstChildWhichIsA("Animator")
        if animator then
            for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                if track.Animation and track.Animation.AnimationId == "rbxassetid://" .. tostring(animationId) then
                    track:Stop()
                end
            end
        end
    end
end

local function isAnimationRunning(char, animationId)
	local humanoid = char:FindFirstChildWhichIsA("Humanoid")
    if humanoid then
        local animator = humanoid:FindFirstChildWhichIsA("Animator")
        if animator then
            for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                if track.Animation and track.Animation.AnimationId == "rbxassetid://" .. tostring(animationId) then
					return true
				else
					return false
                end
            end
        end
    end
end

local function emoteDashSetup(char)
	local hrp = char:WaitForChild("HumanoidRootPart")
	uis.InputBegan:Connect(function(input, t)
		if t then return end
		
		if input.KeyCode == Enum.KeyCode.Q and not uis:IsKeyDown(Enum.KeyCode.W) and not uis:IsKeyDown(Enum.KeyCode.S) and not isAnimationRunning(char, 10491993682) --[[backdash]] then
			local vel = hrp:FindFirstChild("dodgevelocity")
			if vel then
				vel:Destroy()
				stopAnimation(char, 10480793962) -- side dash right
				stopAnimation(char, 10480796021) -- side dash left
			end
		end
	end)
end

if plr.Character then
	noEndlagSetup(plr.Character)
	emoteDashSetup(plr.Character)
end

plr.CharacterAdded:Connect(emoteDashSetup)
plr.CharacterAdded:Connect(noEndlagSetup)

if not getgenv().DisableNotification then
	stgui:SetCore("SendNotification", {
		Title = "[Skidded loaded] made by Alex",
		Icon = "rbxassetid://13333189503",
		Text = "Fuck ego's",
		Duration = 5,
		Button1 = "Dismiss",
		Callback = function() end
	})
end


--// Script 6: auto

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local player = Players.LocalPlayer

local character = player.Character or player.CharacterAdded:Wait()
local tool = nil
local remote = nil
local holdingF = false

-- Find the current tool's attack RemoteEvent
local function getSwingRemote()
	local tool = character:FindFirstChildOfClass("Tool")
	if not tool then return nil end
	local toolScripts = tool:FindFirstChild("ToolScripts")
	if not toolScripts then return nil end
	return toolScripts:FindFirstChildWhichIsA("RemoteEvent")
end

-- Check if Blocking attribute is true
local function isBlocking()
	local live = workspace:FindFirstChild("Live")
	local model = live and live:FindFirstChild(player.Name)
	return model and model:GetAttribute("Blocking") == true
end

-- 🔁 Auto Attack Loop
task.spawn(function()
	while true do
		local remote = getSwingRemote()
		if remote and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
			pcall(function()
				remote:FireServer("LightAttack")
			end)
		end
		task.wait(0.1)
	end
end)

-- 🛡 Auto F Key Spam until Blocking is True
task.spawn(function()
	while true do
		if holdingF and not isBlocking() then
			VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, nil)
			VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, nil)
			task.wait(0.05)
		else
			task.wait(0.1)
		end
	end
end)

-- Input handlers
UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode == Enum.KeyCode.F then
		holdingF = true
	end
end)

UserInputService.InputEnded:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode == Enum.KeyCode.F then
		holdingF = false
	end
end)

-- Update tool/character on respawn
player.CharacterAdded:Connect(function(char)
	character = char
end)



